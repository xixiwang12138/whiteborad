# 记录一次周赛经历，确实让自己信心全无
题目：
给你一个大小为 n x n 的整数矩阵 grid 。

生成一个大小为 (n - 2) x (n - 2) 的整数矩阵  maxLocal ，并满足：

maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。
换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。

返回生成的矩阵。
## 关于优化思路的想法
- 在比赛期间在想，如果可以直接比较九宫格移动新增的三个值与原来的最大值进行比较即可得出正确思路
- 但是可能是自己的题目确实做少了；很傻；其实这个思路是错误的；
- 如果以后遇见这样的使用比较进行得到局部最优的题目，一定需要考虑，更新的时候，最大值所在的地方是不是已经全部包含在比较的数据里

## 暴力解
后来直接使用暴力解，才发现了思路也有问题
- 这是改动之前的代码，一直找不到问题
```GO
func largestLocal(grid [][]int) [][]int {
	n := len(grid)

	ans := make([][]int, n-2)
	for i := 0; i < n-2; i++ {
		ans[i] = make([]int, n-2)
	}
	for i := 0; i < n-2; i++ {
		for j := 0; j < n-2; j++ {
			ans[i][j] = Max(grid, i, j)
		}
	}

	return ans
}

func Max(grid [][]int, i1 , j1 int) int {
	max := grid[i1][j1]
	for i := i1; i < 3; i++ {  //请看这里
		for j := j1; j < 3; j++ {
			if grid[i][j] > max {
				max = grid[i][j]
			}
		}
	}
	return max
}
```
- 本来想的是每一个位置作为九宫格左上角的位置，然后更新这个九宫格内所有的最大值；
- 但是其实发现，我这里循环的结束条件怎么好像没有使得循环为3，直到三就结束了；真的有被蠢死.......